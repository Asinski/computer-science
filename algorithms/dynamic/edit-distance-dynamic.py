def edit_distance(a: str, b: str):
    """
    Пусть через канал связи передается какой-либо сигнал, состоящий из последовательности символов.
    При передаче сигнала возможны искажения - некоторые символы заменяются на другие.
    Число различий между двумя последовательностями сигналов (между двумя строками),
    то есть количество соответствующих символов в последовательностях, которые различаются,
    называется расстоянием Хемминга между строками.
    Расстояние Хемминга (оно определено только для строк равной длины) - это
    количество символов, которые нужно изменить в одной строке, чтобы получить другую строку,
    то есть это мера «близости» двух строк.

    Если разрешать не только менять символы, но также удалять и вставлять символы, то минимальное количество изменений
    (замена символа, удаление символа, вставка символа), которое необходимо сделать с одной строкой,
    чтобы получить другую строку, называется расстоянием Левенштейна
    (в честь российского математика Владимира Левенштейна) или расстоянием редактирования. Такое расстояние появляется,
    например, в системах автоматической проверки орфографии.
    Если при наборе текста человек допустил одну или несколько ошибок,
    то набранное им слово будет отсутствовать в словаре.
    При этом нужно понять, какое слово наборщик имел в виду.
    Если считать, что наиболее типичные ошибки при наборе текста - это
    пропуск символа, вставка лишнего символа или замена одного символа на другой,
    то необходимо неправильное слово заменить на слово из словаря с минимальным расстоянием Левенштейна.

    Расстояние Дамерау — Левенштейна - это + минимальное количество операции транспозиции
    (перестановки двух соседних символов), необходимых для перевода одной строки в другую.
    """
    F = [[i + j if i * j == 0 else 0 for j in range(len(b) + 1)] for i in range(len(a) + 1)]
    for i in range(1, len(a) + 1):
        for j in range(1, len(b) + 1):
            if a[i - 1] == b[j - 1]:
                F[i][j] = F[i - 1][j - 1]
            else:
                F[i][j] = 1 + min(F[i - 1][j - 1], F[i - 1][j], F[i][j - 1])
            if i > 1 and j > 1 and a[i - 1] == b[j - 2] and a[i - 2] == b[j - 1]:
                F[i][j] = min(F[i][j], F[i - 2][j - 2] + 1)

    return F[-1][-1]


def main():
    a = input()
    b = input()
    print(edit_distance(a, b))


if __name__ == "__main__":
    main()
